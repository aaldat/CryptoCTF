# See the attachment for the challenge code. The output is:
# 60509355275518728792864353034381323203712352065221533863094540755630035742080855136016830887120470658395455751858380183285852786807229077435165810022519265154399424311072791755790585544921699474779996198610853766677088209156457859301755313246598035577293799853256065979074343370064111263698164125580000165237
# 44695558076372490838321125335259117268430036823123326565653896322404966549742986308988778274388721345811255801305658387179978736924822440382730114598169989281210266972874387657989210875921956705640740514819089546339431934001119998309992280196600672180116219966257003764871670107271245284636072817194316693323



from Crypto.Util.number import bytes_to_long, getPrime, isPrime, inverse, long_to_bytes
from gmpy2 import next_prime, isqrt

#solution: Fermat's factorization because p and q close numbers

def next_prime(p):
        while True:
            p = p+1
            if isPrime(p):
                return p

if __name__ == '__main__':

    n = 60509355275518728792864353034381323203712352065221533863094540755630035742080855136016830887120470658395455751858380183285852786807229077435165810022519265154399424311072791755790585544921699474779996198610853766677088209156457859301755313246598035577293799853256065979074343370064111263698164125580000165237
    e = 65537
    c = 44695558076372490838321125335259117268430036823123326565653896322404966549742986308988778274388721345811255801305658387179978736924822440382730114598169989281210266972874387657989210875921956705640740514819089546339431934001119998309992280196600672180116219966257003764871670107271245284636072817194316693323

    #Fermat's factorization code
    a = b = isqrt(n)
    b2 = pow(a,2) - n
    # print("a = "+str(a))
    # print("b = "+str(b))
    # print("b2 = "+str(b2))
    # print("Delta--> "+str(pow(b,2)-b2 % n))

    i = 0

    #fattorizzo n come se fosse una differenza di quadrati
    while True:
        print("Iteration #"+str(i))
        if(b2 == pow(b,2)): #b2 Ã¨ un quadrato perfetto -> soluzione trovata
            print("Solution found")
            break
        else:
            a += 1
            b2 = pow(a,2) - n
            b = isqrt(b2)
            print("a = "+str(a))
            print("b = "+str(b))
            print("b2 = "+str(b2))
            print("Delta--> "+str(pow(b,2)-b2 % n))
        
        i += 1

    #uso Fermat per ottenere p e q, poi ricavo phi, d, e quindi il plaintext
    #ricostruisco p e q dai valori a e b
    p = a+b
    q = a-b 

    phi = (p - 1) * (q - 1)
    d = inverse(e, phi)
    m = pow(c, d, n)
    flag = long_to_bytes(m)
    print(flag.decode())